# 任务模型

<cite>
**本文档引用的文件**  
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py)
- [backend/apps/tasks/serializers.py](file://backend/apps/tasks/serializers.py)
- [backend/apps/tasks/views.py](file://backend/apps/tasks/views.py)
- [backend/apps/projects/models.py](file://backend/apps/projects/models.py)
- [frontend/src/types/index.ts](file://frontend/src/types/index.ts)
- [frontend/src/services/task.ts](file://frontend/src/services/task.ts)
- [frontend/src/pages/TasksPage.tsx](file://frontend/src/pages/TasksPage.tsx)
</cite>

## 目录
1. [简介](#简介)
2. [核心字段设计](#核心字段设计)
3. [枚举字段详解](#枚举字段详解)
4. [父子任务层级结构](#父子任务层级结构)
5. [项目关联机制](#项目关联机制)
6. [标星功能实现](#标星功能实现)
7. [任务生命周期管理](#任务生命周期管理)
8. [拖拽排序与查询排序](#拖拽排序与查询排序)
9. [实际查询案例](#实际查询案例)
10. [性能优化建议](#性能优化建议)
11. [级联删除与SET_NULL取舍](#级联删除与set_null取舍)

## 简介
任务模型是本系统的核心数据结构，用于管理用户的所有待办事项。该模型支持任务分解、优先级设置、状态跟踪、时间管理、项目归属和排序等功能，为用户提供全面的任务管理能力。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L4-L74)

## 核心字段设计
任务模型包含以下基础字段：

- **title**：任务标题，最大长度255字符，必填项
- **description**：任务描述，可为空的文本字段，用于详细说明任务内容
- **user**：外键关联到用户模型，表示任务所属用户，采用CASCADE级联删除策略
- **created_at**：创建时间，自动在创建时填充
- **updated_at**：更新时间，每次保存时自动更新

这些字段构成了任务的基本信息框架，确保每个任务都有明确的标识和归属。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L21-L28)

## 枚举字段详解
任务模型定义了两个重要的枚举选择字段，用于标准化任务的优先级和状态。

### 优先级（priority）
```python
PRIORITY_CHOICES = [
    ('none', '无'),
    ('low', '低'),
    ('medium', '中'),
    ('high', '高'),
]
```
优先级字段采用字符类型，最大长度10字符，提供四个等级选择。业务含义如下：
- **无**：不重要或无需优先处理的任务
- **低**：可以延后处理的次要任务
- **中**：常规重要性任务
- **高**：需要优先处理的重要任务

### 状态（status）
```python
STATUS_CHOICES = [
    ('todo', '待办'),
    ('in_progress', '进行中'),
    ('completed', '已完成'),
]
```
状态字段采用字符类型，最大长度20字符，定义任务的生命周期状态：
- **待办**：新创建或未开始的任务
- **进行中**：已经开始处理但未完成的任务
- **已完成**：已经完成的任务

前端通过`TaskDetail.tsx`中的状态按钮组件提供直观的状态切换界面。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L8-L19)

## 父子任务层级结构
任务模型通过自引用外键实现父子任务的层级结构，支持任务分解和子任务管理。

```python
parent = models.ForeignKey(
    'self',
    on_delete=models.CASCADE,
    null=True,
    blank=True,
    related_name='subtasks',
    verbose_name='父任务'
)
```

### 实现机制
- 使用`'self'`作为外键目标，允许任务关联到同一模型的其他实例
- `on_delete=models.CASCADE`确保删除父任务时其所有子任务也被删除
- `null=True, blank=True`允许任务作为顶层任务存在
- `related_name='subtasks'`为反向查询提供便利，可通过`task.subtasks.all()`获取所有子任务

### 实际应用
在任务分解场景中，用户可以将一个复杂任务作为父任务，然后创建多个子任务来表示具体的执行步骤。这种层级结构有助于：
- 将大任务分解为可管理的小任务
- 跟踪子任务的完成情况
- 保持任务之间的逻辑关联

前端通过`TaskDetail`组件支持子任务的查看和管理。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L37-L44)

## 项目关联机制
任务与项目模块通过外键关联，实现任务的分类管理。

```python
project = models.ForeignKey(
    'projects.Project',
    on_delete=models.SET_NULL,
    null=True,
    blank=True,
    related_name='tasks',
    verbose_name='所属项目'
)
```

### 关联策略
- 外键指向`projects.Project`模型
- 采用`SET_NULL`删除策略，当项目被删除时，相关任务的项目字段设为NULL而非删除任务
- `null=True, blank=True`允许任务不属于任何项目（即个人任务）

### 项目模型
项目模型包含名称、描述、颜色、用户归属等字段，并通过`tasks`反向关系管理其任务集合。

前端通过`TasksPage.tsx`中的项目筛选下拉菜单实现任务按项目过滤功能。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L29-L36)
- [backend/apps/projects/models.py](file://backend/apps/projects/models.py#L5-L31)

## 标星功能实现
标星功能允许用户标记重要任务，便于快速查找和重点关注。

```python
is_starred = models.BooleanField(default=False, verbose_name='是否标星')
```

### 实现逻辑
- 布尔字段，默认值为False
- 通过API端点`/tasks/{id}/toggle_star/`实现状态切换
- 前端服务`taskService.toggleStar()`封装了标星切换的HTTP请求

### 前端交互
```typescript
toggleStar: async (id: number): Promise<Task> => {
    const response = await apiClient.post<Task>(`/tasks/${id}/toggle_star/`)
    return response.data
}
```
用户点击标星图标时，前端调用此方法，后端处理程序会翻转`is_starred`字段的值并返回更新后的任务数据。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L61-L61)
- [backend/apps/tasks/views.py](file://backend/apps/tasks/views.py#L38-L45)
- [frontend/src/services/task.ts](file://frontend/src/services/task.ts#L42-L45)

## 任务生命周期管理
任务模型通过三个时间字段精确管理任务的生命周期。

```python
start_date = models.DateTimeField(null=True, blank=True, verbose_name='开始时间')
due_date = models.DateTimeField(null=True, blank=True, verbose_name='截止时间')
completed_at = models.DateTimeField(null=True, blank=True, verbose_name='完成时间')
```

### 时间字段说明
- **start_date**：任务实际开始时间，可为空
- **due_date**：任务截止时间，用于提醒和逾期判断
- **completed_at**：任务完成时间，仅在状态为"已完成"时设置

### 生命周期流程
1. 创建任务时设置`created_at`
2. 开始执行任务时可设置`start_date`
3. 完成任务时，状态变更为"completed"，同时设置`completed_at`
4. 系统根据`due_date`和当前时间判断任务是否逾期

前端日历视图根据`due_date`渲染任务事件，并使用不同颜色区分优先级和状态。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L57-L59)

## 拖拽排序与查询排序
任务模型通过`order`字段支持拖拽排序和查询排序功能。

```python
order = models.IntegerField(default=0, verbose_name='排序')
```

### 拖拽排序实现
前端使用`@dnd-kit`库实现拖拽功能，在`TasksPage.tsx`中处理拖拽结束事件：

```typescript
const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event
    if (over && active.id !== over.id) {
        const oldIndex = filteredTasks.findIndex(task => task.id === active.id)
        const newIndex = filteredTasks.findIndex(task => task.id === over.id)
        const newTasks = arrayMove(filteredTasks, oldIndex, newIndex)
        
        // 更新本地状态
        setTasks(newTasks)
        
        // 批量更新后端order字段
        try {
            await Promise.all(
                newTasks.map((task, index) =>
                    taskService.updateTask(task.id, { order: index })
                )
            )
        } catch (error) {
            // 错误处理和恢复
            loadTasks()
        }
    }
}
```

### 查询排序
在模型元数据中定义默认排序：
```python
class Meta:
    ordering = ['order', '-created_at']
```
这确保在没有指定排序时，任务首先按`order`升序排列，然后按`created_at`降序排列（最新创建的排在同序号任务的后面）。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L60-L60)
- [frontend/src/pages/TasksPage.tsx](file://frontend/src/pages/TasksPage.tsx#L28-L365)

## 实际查询案例
以下是一些常见的任务查询案例：

### 获取某用户所有高优先级未完成任务
```python
def get_high_priority_incomplete_tasks(user):
    return Task.objects.filter(
        user=user,
        priority='high',
        status__in=['todo', 'in_progress']
    ).order_by('-created_at')
```

### 获取今日任务
后端提供专门的API端点：
```python
@action(detail=False, methods=['get'])
def today(self, request):
    today = timezone.now().date()
    tasks = self.get_queryset().filter(
        due_date__date=today,
        status__in=['todo', 'in_progress']
    )
    serializer = self.get_serializer(tasks, many=True)
    return Response(serializer.data)
```

前端通过`taskService.getTodayTasks()`方法调用此API。

### 按项目和状态筛选
```python
def filter_tasks(user, project_id=None, status=None):
    queryset = Task.objects.filter(user=user)
    if project_id:
        queryset = queryset.filter(project_id=project_id)
    if status:
        queryset = queryset.filter(status=status)
    return queryset
```

**Section sources**
- [backend/apps/tasks/views.py](file://backend/apps/tasks/views.py#L47-L56)
- [frontend/src/services/task.ts](file://frontend/src/services/task.ts#L47-L50)

## 性能优化建议
为确保任务模型在大数据量下的性能，建议实施以下优化策略：

### 数据库索引
```python
class Task(models.Model):
    # ... 字段定义 ...
    
    class Meta:
        indexes = [
            # 用户ID索引，加速用户任务查询
            models.Index(fields=['user']),
            # 状态和优先级组合索引，加速筛选查询
            models.Index(fields=['status', 'priority']),
            # 截止日期索引，加速时间相关查询
            models.Index(fields=['due_date']),
            # 项目外键索引，加速项目任务查询
            models.Index(fields=['project']),
            # 标星状态索引，加速重要任务查询
            models.Index(fields=['is_starred']),
            # 排序字段索引，加速排序操作
            models.Index(fields=['order']),
        ]
```

### 查询优化
- 使用`select_related('project')`预加载项目数据，避免N+1查询
- 使用`prefetch_related('subtasks')`预加载子任务
- 对分页查询使用`limit`和`offset`，避免一次性加载过多数据

### 缓存策略
- 对用户任务列表实施客户端缓存
- 对统计信息实施服务器端缓存
- 使用Redis缓存频繁访问的数据

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L66-L70)

## 级联删除与SET_NULL取舍
在任务模型中，不同外键采用了不同的删除策略，这是经过深思熟虑的设计决策。

### CASCADE（级联删除）
```python
parent = models.ForeignKey(
    'self',
    on_delete=models.CASCADE,
    # ...
)
```
对于父子任务关系，采用CASCADE策略。当父任务被删除时，其所有子任务也应被删除，因为子任务失去了存在的上下文和意义。这保证了数据的一致性和完整性。

### SET_NULL
```python
project = models.ForeignKey(
    'projects.Project',
    on_delete=models.SET_NULL,
    null=True,
    # ...
)
```
对于项目关联，采用SET_NULL策略。当项目被删除时，相关任务不会被删除，而是将其项目字段设为NULL。这种设计的考虑是：
- 任务本身可能仍有价值，不应因项目删除而丢失
- 用户可能希望保留任务历史记录
- 任务可以重新分配到其他项目或作为独立任务存在

这种取舍平衡了数据完整性与用户体验，确保重要任务数据不会意外丢失。

**Section sources**
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L30-L36)
- [backend/apps/tasks/models.py](file://backend/apps/tasks/models.py#L38-L44)