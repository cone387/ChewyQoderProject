# 反向代理配置

<cite>
**Referenced Files in This Document**  
- [nginx.conf](file://frontend/nginx.conf)
- [docker-compose.yml](file://docker-compose.yml)
- [Dockerfile](file://frontend/Dockerfile)
</cite>

## 目录
1. [Nginx反向代理核心配置](#nginx反向代理核心配置)
2. [容器间通信机制解析](#容器间通信机制解析)
3. [请求头转发与客户端信息传递](#请求头转发与客户端信息传递)
4. [静态资源缓存策略](#静态资源缓存策略)
5. [配置调试与常见问题排查](#配置调试与常见问题排查)

## Nginx反向代理核心配置

`frontend/nginx.conf` 文件中的 `server` 块定义了Nginx的核心行为。该服务监听80端口，将 `root` 指令指向 `/usr/share/nginx/html`，这是前端构建产物（由 `frontend/Dockerfile` 中的 `COPY --from=builder /app/dist /usr/share/nginx/html` 指令复制）的存放目录。

为支持React Router的HTML5 History模式，配置中使用了 `location /` 块的 `try_files` 指令。该指令尝试按顺序查找文件：首先查找请求的URI对应的文件，若不存在则查找对应目录，若仍不存在则返回 `/index.html`。这确保了即使用户直接访问如 `/tasks` 或 `/projects` 等非根路径，Nginx也能正确返回 `index.html`，从而让前端路由接管并渲染相应页面，避免了404错误。

**Section sources**
- [nginx.conf](file://frontend/nginx.conf#L1-L16)

## 容器间通信机制解析

`location /api` 块是反向代理的关键，它将所有以 `/api` 开头的请求代理到后端服务。`proxy_pass http://backend:8000;` 指令中的 `backend` 并非IP地址，而是Docker Compose网络中的服务名称。

在 `docker-compose.yml` 文件中，`backend` 服务被定义，其容器名为 `todo-backend`，并暴露8000端口。当Nginx（运行在 `frontend` 容器中）尝试访问 `http://backend:8000` 时，Docker的内建DNS会自动将 `backend` 这个主机名解析为 `todo-backend` 容器的IP地址。这种基于服务名称的通信是Docker Compose的核心特性，它简化了容器间的网络配置，使得服务可以相互发现和通信，而无需关心具体的IP地址。

**Section sources**
- [nginx.conf](file://frontend/nginx.conf#L18-L24)
- [docker-compose.yml](file://docker-compose.yml#L21-L44)

## 请求头转发与客户端信息传递

`proxy_set_header` 指令在请求转发过程中扮演着至关重要的角色，它确保了后端应用能够获取到关于原始客户端的真实信息。

- **`proxy_set_header Host $host;`**: 将原始请求的Host头（如 `localhost`）传递给后端。这对于后端生成正确的绝对URL（如重定向链接）至关重要。
- **`proxy_set_header X-Real-IP $remote_addr;`**: 将Nginx接收到请求的客户端真实IP地址（`$remote_addr`）设置为 `X-Real-IP` 头。这使得后端可以直接读取此头来获取用户IP，用于日志记录、访问控制或地理位置分析。
- **`proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;`**: `X-Forwarded-For` 是一个标准的HTTP头，用于记录请求经过的代理链。`$proxy_add_x_forwarded_for` 变量会将客户端IP追加到已有的 `X-Forwarded-For` 头值之后（如果存在），形成一个IP地址列表。这有助于后端识别完整的请求路径。
- **`proxy_set_header X-Forwarded-Proto $scheme;`**: 将原始请求的协议（`http` 或 `https`）通过 `X-Forwarded-Proto` 头传递给后端。这对于后端判断请求是否安全（HTTPS）以及生成正确的重定向URL（例如，强制HTTPS）非常关键。

这些头信息的正确传递，使得后端应用在Nginx代理之后，依然能像直接暴露在公网一样，准确地感知客户端的原始信息。

**Section sources**
- [nginx.conf](file://frontend/nginx.conf#L20-L23)

## 静态资源缓存策略

为了提升前端性能，配置中专门针对静态资源设置了缓存策略。`location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$` 使用正则表达式匹配常见的静态文件扩展名（`~*` 表示不区分大小写）。

- **`expires 1y;`**: 该指令为匹配的响应添加 `Expires` 头和 `Cache-Control: max-age` 头，将其值设置为1年。这告诉浏览器和中间缓存（如CDN）可以将这些资源缓存长达一年。
- **`add_header Cache-Control "public, immutable";`**: 显式添加 `Cache-Control` 头。`public` 表示响应可以被任何缓存（包括代理服务器）存储。`immutable` 是一个重要的优化，它告知浏览器该资源的内容在缓存有效期内永远不会改变。因此，浏览器在后续访问时将完全跳过对这些资源的条件请求（如 `If-None-Match`），直接使用本地缓存，从而显著减少HTTP请求和网络延迟。

这一策略极大地提升了页面加载速度和用户体验。

**Section sources**
- [nginx.conf](file://frontend/nginx.conf#L26-L30)

## 配置调试与常见问题排查

### 调试方法
1.  **语法检查**: 在修改 `nginx.conf` 后，应使用 `nginx -t` 命令检查配置文件语法是否正确，避免因配置错误导致服务无法启动。
2.  **日志查看**: Nginx的访问日志和错误日志是排查问题的第一手资料。通过分析日志，可以确认请求是否被正确路由、代理是否成功、以及错误发生的具体原因。
3.  **连通性测试**: 可以进入 `frontend` 容器内部，使用 `curl` 命令直接测试 `http://backend:8000` 的连通性，以验证容器间网络是否正常。

### 常见问题排查
- **跨域失败 (CORS)**: 如果后端返回CORS错误，首先检查 `docker-compose.yml` 中 `backend` 服务的 `CORS_ALLOWED_ORIGINS` 环境变量是否包含了前端的地址（如 `http://localhost`）。Nginx代理本身不会引起CORS问题，问题通常出在后端的CORS配置上。
- **路径重写错误**: 如果API请求返回404，需检查 `proxy_pass` 指令的URL是否正确。例如，`proxy_pass http://backend:8000/api/;` 会将 `/api/xxx` 重写为 `/api/xxx`，而 `proxy_pass http://backend:8000/;` 则会将 `/api/xxx` 重写为 `/xxx`。确保后端服务的路由与代理路径匹配。
- **HTTPS转发异常**: 当Nginx配置了HTTPS时，必须确保 `proxy_set_header X-Forwarded-Proto $scheme;` 被正确设置。如果后端应用依赖此头来判断协议，但Nginx未传递，可能导致后端错误地认为请求是HTTP，从而产生重定向循环或安全警告。

**Section sources**
- [nginx.conf](file://frontend/nginx.conf)
- [docker-compose.yml](file://docker-compose.yml)
- [Dockerfile](file://frontend/Dockerfile)